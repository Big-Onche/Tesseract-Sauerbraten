volopt = [ >= (strstr $volumetrictype $arg1) 0 ]

volumetricvariantshader = [
    local volumetrictype
    volumetrictype = $arg3
    maxsteps = $arg4
    spotlight = (>= $arg2 2)
    colorshadow = (>= (mod (+ $arg2 1) 3) 2)
    variantshader 0 $arg1 $arg2 (? (< $arg2 0) [
        attribute vec4 vvertex;
        uniform mat4 lightmatrix;
        void main(void)
        {
            gl_Position = lightmatrix * vvertex;
        }
    ]) [
        @(gfetchdefs tex3)
        @(if (volopt "p") [
            if (|| (volopt "g") (volopt "G")) [if (> $usetexgather 1) [result [
                uniform sampler2DShadow tex4;
            ]] [result [
                uniform sampler2D tex4;
            ]]] [result [
                uniform sampler2DRectShadow tex4;
            ]]
        ])
        @(if $colorshadow [result [
            uniform sampler2DRect tex11;
            #define filtercolorshadow(tc) texture2DRect(tex11, tc.xy @(? (! (volopt "N")) [* 0.5])).rgb
            #define lightshadowtype vec3
        ]] [result [
            #define lightshadowtype float
        ]])
        uniform vec4 lightpos;
        uniform vec3 lightcolor; 
        @(? $spotlight [
            uniform vec4 spotparams;
        ])
        @(? (volopt "p") [
            uniform vec4 shadowparams;
            uniform vec2 shadowoffset;
        ])
        uniform vec3 camera;
        uniform mat4 worldmatrix;
        uniform vec4 fogdir;
        uniform vec3 fogcolor;
        uniform vec2 fogdensity;
        uniform vec4 radialfogscale;
        uniform vec2 shadowatlasscale;
        uniform vec4 volscale;
        uniform float volminstep;
        uniform float voldistclamp;
        uniform float volprefilter;
        fragdata(0) vec4 fragcolor;

        @(if (volopt "p") [
            ? $spotlight [
                vec3 getspottc(vec3 dir, float spotdist)
                {
                    vec2 mparams = shadowparams.xy / max(spotdist, 1e-5);
                    return vec3((dir.xy - spotparams.xy*(spotdist + (spotparams.z < 0.0 ? -1.0 : 1.0)*dir.z)*shadowparams.z) * mparams.x + shadowoffset, mparams.y + shadowparams.w);
                }
            ] [
                vec3 getshadowtc(vec3 dir)
                {
                    vec3 adir = abs(dir);
                    float m = max(adir.x, adir.y), mz = max(adir.z, m);
                    vec2 mparams = shadowparams.xy / max(mz, 1e-5);
                    vec4 proj;
                    if(adir.x > adir.y) proj = vec4(dir.zyx, 0.0); else proj = vec4(dir.xzy, 1.0);
                    if(adir.z > m) proj = vec4(dir, 2.0);
                    return vec3(proj.xy * mparams.x + vec2(proj.w, step(proj.z, 0.0)) * shadowparams.z + shadowoffset, mparams.y + shadowparams.w);
                }
            ]
        ])

        @(if (volopt "p") [
            if (|| (volopt "g") (volopt "G")) [
                ? (> $usetexgather 1) [
                    #define filtershadow(shadowtc) float(shadow2D(tex4, vec3(shadowtc.xy*shadowatlasscale, shadowtc.z)))
                ] [
                    #define filtershadow(shadowtc) step(shadowtc.z, float(texture2D(tex4, shadowtc.xy*shadowatlasscale)))
                ]
            ] [result [
                #define filtershadow(shadowtc) float(shadow2DRect(tex4, shadowtc))
            ]]
        ])
    
        void main(void)
        {
            vec2 tc = gl_FragCoord.xy * volscale.xy;
            @(gdepthunpack depth [gfetch(tex3, tc)] [
                vec3 pos = (worldmatrix * vec4(depth*tc, depth, 1.0)).xyz;
            ] [
                vec4 pos = worldmatrix * vec4(tc, depth, 1.0);
                pos.xyz /= pos.w;
            ])
            vec3 ray = pos.xyz - camera;
            float dist2 = dot(ray, ray), invdist = inversesqrt(dist2), radialdist = min(dist2 * invdist, voldistclamp);
            ray *= invdist;
            vec3 camlight = lightpos.xyz - camera * lightpos.w;
            float camlight2 = dot(camlight, camlight), v = dot(camlight, ray), d = v*v + 1.0 - camlight2;
            lightshadowtype light = lightshadowtype(0.0);
            if(d > 0)
            {
                d = sqrt(d);
                float front = v - d, back = v + d;
                @(? $spotlight [
                    float spotangle = 1.0 - 1.0/spotparams.w, spotangle2 = spotangle*spotangle,
                          rayspot = dot(ray, spotparams.xyz), camspot = dot(camlight, spotparams.xyz),
                          qa = spotangle2 - rayspot*rayspot,
                          qb = rayspot*camspot - spotangle2*v,
                          qc = spotangle2*camlight2 - camspot*camspot,
                          disc = qb*qb - qa*qc;
                    if(disc > 0)
                    {
                        disc = abs(sqrt(disc)/qa);
                        float t = -qb/qa, t0 = t - disc, t1 = t + disc;
                        if(t0*rayspot < camspot) front = max(front, t1);
                        else if(t1*rayspot < camspot) back = min(back, t0);
                        else { front = max(front, t0); back = min(back, t1); }
                ])
                float maxspace = back - front, stepdist = maxspace * @(divf 1.0 $maxsteps);
                front = max(front, 0.0);
                back = min(back, radialdist * lightpos.w);
                float space = back - front;
                if(space > volminstep*stepdist)
                {
                    float dither = dot(fract((gl_FragCoord.xy - 0.5).xyxy*vec4(0.5, 0.5, 0.25, 0.25)), vec4(0.375, 0.9375, 0.25, 0.125));
                    vec3 lightdir = ray * (back + stepdist*dither) - camlight;
                    vec3 raystep = ray * -stepdist;
                    for(int i = 0; i < @maxsteps; i++)
                    {
                        lightdir += raystep;
                        @(if $spotlight [result [
                            float lightdist2 = dot(lightdir, lightdir);
                            float lightinvdist = inversesqrt(lightdist2); 
                            float spotdist = dot(lightdir, spotparams.xyz);
                            float spotatten = 1.0 - (1.0 - lightinvdist * spotdist) * spotparams.w;
                            if(spotatten > 0.0)
                            {
                                float lightatten = clamp(1.0 - lightdist2 * lightinvdist, 0.0, 1.0) * spotatten;
                                @(? (volopt "p") [
                                    vec3 spottc = getspottc(lightdir, spotdist);
                                    lightatten *= filtershadow(spottc);
                                ])
                                light += lightatten @(? $colorshadow [* filtercolorshadow(spottc)]);
                            }
                        ]] [result [
                            float lightatten = clamp(1.0 - length(lightdir), 0.0, 1.0);
                            @(? (volopt "p") [
                                vec3 shadowtc = getshadowtc(lightdir);
                                lightatten *= filtershadow(shadowtc);
                            ])
                            light += lightatten @(? $colorshadow [* filtercolorshadow(shadowtc)]);
                        ]])
                        space -= stepdist;
                        if(space <= 0) break; 
                    }
                    float fogcoord = front/lightpos.w;
                    float foglerp = clamp(exp2(fogcoord*fogdensity.x)*fogdensity.y, 0.0, 1.0);
                    light *= foglerp * stepdist;
                    @(? $spotlight [
                        light /= min(maxspace, 1.0);
                    ])
                }
                @(? $spotlight [}])
            }
            vec2 weights = step(fwidth(radialdist), volprefilter) * (2.0*fract((gl_FragCoord.xy - 0.5)*0.5) - 0.5);
            light -= dFdx(light) * weights.x;
            light -= dFdy(light) * weights.y;
            fragcolor.rgb = light * lightcolor;
            fragcolor.a = 0.0;
        }
    ]
]

volumetricshader = [
    volumetrictype = (concatword $arg1 $arg2)
    shadername = (concatword "volumetric" $volumetrictype $arg3)
    volumetricvariantshader $shadername -1 $arg1 $arg3
    volumetricvariantshader $shadername 0 (concatword $arg1 $arg2) $arg3
    if (volopt "P") [
      volumetricvariantshader $shadername 1 (concatword $arg1 $arg2) $arg3
    ]
    if (volopt "s") [
        volumetricvariantshader $shadername 2 $arg1 $arg3
        volumetricvariantshader $shadername 3 (concatword $arg1 $arg2) $arg3    
        if (volopt "P") [
            volumetricvariantshader $shadername 4 (concatword $arg1 $arg2) $arg3
        ]
    ]
]

volumetricbilateralvariantshader = [
    numtaps = $arg2
    reduced = $arg3 
    filterdir = $arg4
    shader 0 $arg1 [
        attribute vec4 vvertex;
        @(if $reduced [result [
            @(screentexcoord 0)
            varying vec2 texcoord0;
        ]])
        void main(void)
        {
            gl_Position = vvertex;
            @(? $reduced [texcoord0 = vtexcoord0;])
        }
    ] [
        @(gfetchdefs tex3)
        uniform sampler2DRect tex0;
        uniform vec2 bilateralparams;
        @(? $reduced [varying vec2 texcoord0;])
        fragdata(0) vec4 fragcolor;
        void main(void)
        {
            #define tc gl_FragCoord.xy
            #define depthtc @(? $reduced [texcoord0] [gl_FragCoord.xy])
            #define tapvec(type, i) @(? (=s $filterdir "x") [type(i, 0.0)] [type(0.0, i)])
            #define texval(i) texture2DRect(tex0, tc + tapvec(vec2, i))
            #define texvaloffset(i) texture2DRectOffset(tex0, tc, tapvec(ivec2, i))
            #define depthval(i) gfetch(tex3, depthtc + tapvec(vec2, i))
            #define depthvaloffset(i) gfetchoffset(tex3, depthtc, tapvec(ivec2, i))
            vec3 color = texture2DRect(tex0, tc).rgb;
            @(gdepthunpack depth [gfetch(tex3, depthtc)])
            float weights = 1.0;
            @(loopconcat i (* 2 $numtaps) [
                curtap = (- $i $numtaps)
                if (>= $curtap 0) [curtap = (+ $curtap 1)]
                curtapoffset = (* $curtap 2)
                curdepthoffset = (<< $curtapoffset $reduced)
                curtexval = [texval@(? (<= $mintexrectoffset $curtapoffset $maxtexrectoffset) "offset")(@(+f $curtapoffset))]
                curdepthval = [depthval@(? (<= $mintexrectoffset $curdepthoffset $maxtexrectoffset) "offset")(@(+f $curdepthoffset))]
                result [
                    vec3 color@[i] = @[curtexval].rgb;
                    @(gdepthunpack [depth@[i]] $curdepthval)
                    depth@[i] -= depth;
                    float weight@[i] = exp2(@(-f 0 (* $curtap $curtap))*bilateralparams.x - depth@[i]*depth@[i]*bilateralparams.y); 
                    weights += weight@[i];
                    color += weight@[i] * color@[i];
                ]
            ])
            fragcolor = vec4(color / weights, 0.0);
        }
    ]
]

volumetricbilateralshader = [
    volumetricbilateralvariantshader (concatword "volumetricbilateralx" $arg1 $arg2) $arg1 $arg2 x
    volumetricbilateralvariantshader (concatword "volumetricbilateraly" $arg1 $arg2) $arg1 $arg2 y
]

lazyshader 0 "volumetricclouds" [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    @(gfetchdefs tex8 $msaalight ngfetch)
    @(gfetchdefs tex9)
    uniform vec3 camera;
    uniform vec3 sunlightdir;
    uniform mat4 worldmatrix;
    uniform vec4 tvcloudscale; // x,y = fullres/rt, z,w = rt/fullres
    uniform vec4 tvcloudbounds; // x=base z, y=top z, z=max dist, w=time
    uniform vec4 tvcloudnoise;  // x=base scale, y=detail scale, z=threshold, w=density
    uniform float vclouddensity;
    uniform float vcloudalpha;
    uniform float vcloudthickness;
    uniform float tvcloudsteps;
    uniform float tvcloudsunsteps;
    uniform vec3 vcloudcolour;
    fragdata(0) vec4 fragcolor;

    float tvhash(vec3 p)
    {
        return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123);
    }

    float tvnoise3(vec3 p)
    {
        vec3 i = floor(p), f = fract(p);
        vec3 u = f*f*(3.0 - 2.0*f);

        float n000 = tvhash(i + vec3(0.0, 0.0, 0.0));
        float n100 = tvhash(i + vec3(1.0, 0.0, 0.0));
        float n010 = tvhash(i + vec3(0.0, 1.0, 0.0));
        float n110 = tvhash(i + vec3(1.0, 1.0, 0.0));
        float n001 = tvhash(i + vec3(0.0, 0.0, 1.0));
        float n101 = tvhash(i + vec3(1.0, 0.0, 1.0));
        float n011 = tvhash(i + vec3(0.0, 1.0, 1.0));
        float n111 = tvhash(i + vec3(1.0, 1.0, 1.0));

        float nx00 = mix(n000, n100, u.x);
        float nx10 = mix(n010, n110, u.x);
        float nx01 = mix(n001, n101, u.x);
        float nx11 = mix(n011, n111, u.x);
        float nxy0 = mix(nx00, nx10, u.y);
        float nxy1 = mix(nx01, nx11, u.y);
        return mix(nxy0, nxy1, u.z);
    }

    float tvfbm(vec3 p)
    {
        float v = 0.0, a = 0.5;
        for(int i = 0; i < 4; ++i)
        {
            v += a * tvnoise3(p);
            p = p * 2.03 + vec3(7.3, 19.1, 3.7);
            a *= 0.5;
        }
        return v;
    }

    float tvdensity(vec3 p)
    {
        float thickness = max(tvcloudbounds.y - tvcloudbounds.x, 1.0);
        float h = clamp((p.z - tvcloudbounds.x) / thickness, 0.0, 1.0);
        float layer = smoothstep(0.05, 0.35, h) * (1.0 - smoothstep(0.65, 0.98, h));

        vec3 windp = p;
        windp.xy += vec2(tvcloudbounds.w * 28.0, tvcloudbounds.w * 12.0);
        windp.z += tvcloudbounds.w * 2.0;

        float densityk = clamp(vclouddensity, 0.0, 2.0);
        float overcast = densityk * 0.5;
        float base = tvfbm(windp * tvcloudnoise.x);
        float detail = tvfbm((windp + vec3(13.0, -9.0, 17.0)) * tvcloudnoise.y);
        float threshold = mix(tvcloudnoise.z + 0.22, tvcloudnoise.z - 0.14, overcast);
        float shape = mix(base, detail, 0.18);
        shape = smoothstep(threshold - 0.03, threshold + 0.18, shape);
        float edge = 1.0 - smoothstep(0.08, 0.75, shape);
        float erosion = smoothstep(0.35, 0.80, detail);
        float billow = smoothstep(0.20, 0.85, detail);
        float d = shape * (1.0 - 0.30 * edge * erosion);
        d *= mix(0.90, 1.14, billow * shape);
        d = clamp(d, 0.0, 1.0);
        float densityamp = mix(0.40, 1.35, overcast);
        return d * layer * tvcloudnoise.w * densityamp;
    }

    float tvextworldscale()
    {
        return max(tvcloudnoise.x, 1.0e-5);
    }

    float tvbeeralpha(float sigma, float alphamax)
    {
        sigma = clamp(sigma, 0.0, 8.0);
        return min(1.0 - exp(-sigma), alphamax);
    }

    float tvhgphase(float cosTheta, float g)
    {
        float g2 = g * g;
        float denom = max(1.0 + g2 - 2.0 * g * cosTheta, 1.0e-4);
        return (1.0 - g2) / pow(denom, 1.5);
    }

    float tvsuntrans(vec3 p, vec3 sdir, float thickness, float sunext)
    {
        if(sdir.z <= 1.0e-3) return 1.0;
        float tmax = (tvcloudbounds.y - p.z) / sdir.z;
        if(tmax <= 0.0) return 1.0;

        tmax = min(tmax, thickness * 6.0);
        const int TV_SUN_STEPS_MAX = 32;
        int sunsteps = int(clamp(tvcloudsunsteps, 2.0, float(TV_SUN_STEPS_MAX)));
        float stepdist = max(tmax / float(sunsteps), 1.0e-3);
        float t = stepdist * 0.35;
        float trans = 1.0;
        for(int j = 0; j < TV_SUN_STEPS_MAX; ++j)
        {
            if(j >= sunsteps) break;
            float d = tvdensity(p + sdir * t);
            float sigma = d * stepdist * sunext;
            float a = tvbeeralpha(sigma, 0.65);
            trans *= 1.0 - a;
            t += stepdist;
            if(trans < 0.05) break;
        }
        return trans;
    }

    void main(void)
    {
        // Map low-res pixel centers to a deterministic full-res texel center.
        // Avoid sampling exact texel edges (e.g. 2x upscale -> integer coords) which can shimmer with rect+nearest depth fetches.
        vec2 screentc = (gl_FragCoord.xy - vec2(0.5)) * tvcloudscale.xy + vec2(0.5);
        // Explicit sky can write depth without gbuffer normals; treat it as background.
        vec4 normalsample = ngfetch(tex8, screentc);
        bool hasscene = dot(normalsample.rgb, normalsample.rgb) > 1.0e-6;
        @(gdepthunpack depth [gfetch(tex9, screentc)] [
            vec3 wpos = (worldmatrix * vec4(depth*screentc, depth, 1.0)).xyz;
        ] [
            vec4 wpos = worldmatrix * vec4(screentc, depth, 1.0);
            wpos.xyz /= wpos.w;
        ])

        vec3 rayvec = wpos.xyz - camera;
        float raydist = length(rayvec);
        if(!(raydist > 0.0))
        {
            fragcolor = vec4(0.0);
            return;
        }
        float scenedist = hasscene ? min(raydist, tvcloudbounds.z) : tvcloudbounds.z;
        if(scenedist <= 1.0)
        {
            fragcolor = vec4(0.0);
            return;
        }

        vec3 ray = rayvec / max(raydist, 1.0e-4);
        float t0 = 0.0, t1 = scenedist;

        if(abs(ray.z) < 1.0e-4)
        {
            if(camera.z < tvcloudbounds.x || camera.z > tvcloudbounds.y)
            {
                fragcolor = vec4(0.0);
                return;
            }
        }
        else
        {
            float invrz = 1.0 / ray.z;
            float tz0 = (tvcloudbounds.x - camera.z) * invrz;
            float tz1 = (tvcloudbounds.y - camera.z) * invrz;
            if(tz0 > tz1) { float t = tz0; tz0 = tz1; tz1 = t; }
            t0 = max(t0, tz0);
            t1 = min(t1, tz1);
        }

        float tentry = t0;
        bool insideLayer = (camera.z >= tvcloudbounds.x && camera.z <= tvcloudbounds.y);
        t0 = max(t0, insideLayer ? 0.1 : 24.0);
        if(t1 <= t0)
        {
            fragcolor = vec4(0.0);
            return;
        }

        const int TV_STEPS_MAX = 128;
        float thickness = max(tvcloudbounds.y - tvcloudbounds.x, 1.0);
        float extworld = tvextworldscale();
        float viewext = extworld * (12.0 * clamp(vcloudalpha, 0.0, 1.0));
        float sunext = extworld * (10.0 * max(vcloudthickness, 0.0));
        int marchsteps = int(clamp(tvcloudsteps, 4.0, float(TV_STEPS_MAX)));
        float raylen = t1 - t0;
        float stepdist = raylen / float(marchsteps);
        // Stable full-range jitter: avoids temporal shimmer while keeping enough
        // phase variation to hide raymarch banding.
        float jitter = tvhash(vec3(floor(gl_FragCoord.xy), 17.0));
        float t = t0 + jitter * stepdist;
        float slen = max(length(sunlightdir), 1.0e-4);
        vec3 sdir = sunlightdir / slen;
        float sunup = clamp(sdir.z * 0.5 + 0.5, 0.0, 1.0);

        vec3 accum = vec3(0.0);
        float trans = 1.0;
        for(int i = 0; i < TV_STEPS_MAX; ++i)
        {
            if(i >= marchsteps) break;
            if(t > t1 || trans < 0.03) break;

            vec3 p = camera + ray * t;
            float d = tvdensity(p);
            if(d > 1.0e-4)
            {
                float h = clamp((p.z - tvcloudbounds.x) / thickness, 0.0, 1.0);
                float suntrans = tvsuntrans(p, sdir, thickness, sunext);
                float cosT = clamp(dot(ray, sdir), -1.0, 1.0);
                float phase = clamp(tvhgphase(cosT, 0.55) * 0.08, 0.0, 1.5);
                float ambient = mix(0.22, 0.42, h) + 0.18 * sunup;
                float direct = max(sdir.z, 0.0) * suntrans * (0.35 + 0.95 * phase);
                float light = ambient + direct;
                light *= mix(0.80, 1.05, tvnoise3(p * (tvcloudnoise.x * 0.35) + vec3(2.0, 11.0, 5.0)));

                float sigma = d * stepdist * viewext;
                float alpha = tvbeeralpha(sigma, 0.55);
                vec3 basecol = max(vcloudcolour, vec3(0.0));
                vec3 litcol = mix(basecol * vec3(0.78, 0.82, 0.90), basecol, suntrans);
                vec3 samplecol = litcol * light;

                accum += trans * alpha * samplecol;
                trans *= 1.0 - alpha;
            }

            t += stepdist;
        }

        float outalpha = 1.0 - trans;
        float nearfade = tentry <= 0.0 ? 1.0 : smoothstep(0.0, 8.0, tentry);
        outalpha *= nearfade;
        fragcolor = vec4(accum, outalpha);
    }
]


lazyshader 0 "volumetriccloudsbilateral" [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    // tex0 = low-res cloud RT (RGBA)
    uniform sampler2DRect tex0;
    // tex9 = full-res scene depth (rect or msaa)
    @(gfetchdefs tex9 $msaalight)
    uniform vec4 tvcloudscale;           // xy = fullres/rt, zw = rt/fullres
    uniform float tvbilateraldepthscale; // scales raw depth differences
    uniform float vcblurscale;           // bilateral tap spacing in full-res pixels
    uniform vec4 viewsize;
    fragdata(0) vec4 fragcolor;

    float fetchDepthLinear(vec2 uv)
    {
        @(gdepthunpack depth [gfetch(tex9, uv)])
        return depth;
    }

    float gaussian1d(int i)
    {
        // Wider 7-tap kernel (sigma ~1.8) for aggressive smoothing of cloud jitter.
        if(i == 0 || i == 6) return 0.036;
        if(i == 1 || i == 5) return 0.111;
        if(i == 2 || i == 4) return 0.217;
        return 0.272;
    }

    void main(void)
    {
        vec2 uv = gl_FragCoord.xy;
        float blurstep = max(vcblurscale, 1.0);
        float centerDepth = fetchDepthLinear(uv);

        vec4 accumCloud = vec4(0.0);
        float totalWeight = 0.0;

        for(int dy = -3; dy <= 3; dy++)
        {
            for(int dx = -3; dx <= 3; dx++)
            {
                vec2 sampleUV = clamp(uv + vec2(float(dx), float(dy)) * blurstep, vec2(0.5), viewsize.xy - vec2(0.5));

                // Snap cloud sampling to the corresponding low-res texel center so depth
                // comparison uses a representative depth for the same cloud sample.
                vec2 cloudPix = floor(sampleUV * tvcloudscale.zw);
                vec2 cloudUV = cloudPix + vec2(0.5);
                vec2 depthProbeUV = clamp(cloudPix * tvcloudscale.xy + vec2(0.5), vec2(0.5), viewsize.xy - vec2(0.5));

                float sampleDepth = fetchDepthLinear(depthProbeUV);
                float depthDiff = abs(sampleDepth - centerDepth) * tvbilateraldepthscale;
                if(depthDiff > 3.0) continue;
                float depthWeight = exp(-depthDiff * depthDiff);

                float spatialWeight = gaussian1d(dx + 3) * gaussian1d(dy + 3);
                float w = spatialWeight * depthWeight;

                accumCloud += texture2DRect(tex0, cloudUV) * w;
                totalWeight += w;
            }
        }

        fragcolor = accumCloud / max(totalWeight, 1.0e-5);
    }
]

lazyshader 0 "volumetriccloudshadowmap" [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    uniform vec4 tvcloudbounds;      // x=base z, y=top z, z=max dist, w=time
    uniform vec4 tvcloudnoise;       // x=base scale, y=detail scale, z=threshold, w=density
    uniform float vclouddensity;
    uniform float vcloudthickness;   // reused as shadow opacity/strength
    uniform vec4 tvshadowmapworld;   // x=minx, y=miny, z=world units/texel, w=map size
    uniform float tvcloudshadowsamples;
    fragdata(0) vec4 fragcolor;

    float tvhash(vec3 p)
    {
        return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123);
    }

    float tvnoise3(vec3 p)
    {
        vec3 i = floor(p), f = fract(p);
        vec3 u = f*f*(3.0 - 2.0*f);

        float n000 = tvhash(i + vec3(0.0, 0.0, 0.0));
        float n100 = tvhash(i + vec3(1.0, 0.0, 0.0));
        float n010 = tvhash(i + vec3(0.0, 1.0, 0.0));
        float n110 = tvhash(i + vec3(1.0, 1.0, 0.0));
        float n001 = tvhash(i + vec3(0.0, 0.0, 1.0));
        float n101 = tvhash(i + vec3(1.0, 0.0, 1.0));
        float n011 = tvhash(i + vec3(0.0, 1.0, 1.0));
        float n111 = tvhash(i + vec3(1.0, 1.0, 1.0));

        float nx00 = mix(n000, n100, u.x);
        float nx10 = mix(n010, n110, u.x);
        float nx01 = mix(n001, n101, u.x);
        float nx11 = mix(n011, n111, u.x);
        float nxy0 = mix(nx00, nx10, u.y);
        float nxy1 = mix(nx01, nx11, u.y);
        return mix(nxy0, nxy1, u.z);
    }

    float tvfbm(vec3 p)
    {
        float v = 0.0, a = 0.5;
        for(int i = 0; i < 4; ++i)
        {
            v += a * tvnoise3(p);
            p = p * 2.03 + vec3(7.3, 19.1, 3.7);
            a *= 0.5;
        }
        return v;
    }

    float tvdensity(vec3 p)
    {
        float thickness = max(tvcloudbounds.y - tvcloudbounds.x, 1.0);
        float h = clamp((p.z - tvcloudbounds.x) / thickness, 0.0, 1.0);
        float layer = smoothstep(0.05, 0.35, h) * (1.0 - smoothstep(0.65, 0.98, h));

        vec3 windp = p;
        windp.xy += vec2(tvcloudbounds.w * 28.0, tvcloudbounds.w * 12.0);
        windp.z += tvcloudbounds.w * 2.0;

        float densityk = clamp(vclouddensity, 0.0, 2.0);
        float overcast = densityk * 0.5;
        float base = tvfbm(windp * tvcloudnoise.x);
        float detail = tvfbm((windp + vec3(13.0, -9.0, 17.0)) * tvcloudnoise.y);
        float threshold = mix(tvcloudnoise.z + 0.22, tvcloudnoise.z - 0.14, overcast);
        float shape = mix(base, detail, 0.18);
        shape = smoothstep(threshold - 0.03, threshold + 0.18, shape);
        float edge = 1.0 - smoothstep(0.08, 0.75, shape);
        float erosion = smoothstep(0.35, 0.80, detail);
        float billow = smoothstep(0.20, 0.85, detail);
        float d = shape * (1.0 - 0.30 * edge * erosion);
        d *= mix(0.90, 1.14, billow * shape);
        d = clamp(d, 0.0, 1.0);
        float densityamp = mix(0.40, 1.35, overcast);
        return d * layer * tvcloudnoise.w * densityamp;
    }

    void main(void)
    {
        vec2 worldxy = tvshadowmapworld.xy + gl_FragCoord.xy * tvshadowmapworld.z;
        float thickness = max(tvcloudbounds.y - tvcloudbounds.x, 1.0);

        int nsamples = int(clamp(tvcloudshadowsamples, 1.0, 8.0));
        float densitysum = 0.0;
        for(int i = 0; i < 8; ++i)
        {
            if(i >= nsamples) break;
            float h = nsamples <= 1 ? 0.6 : (float(i) + 0.5) / float(nsamples);
            densitysum += tvdensity(vec3(worldxy, mix(tvcloudbounds.x, tvcloudbounds.y, h)));
        }

        float densityavg = densitysum / float(max(nsamples, 1));
        float shadowk = 8.0 * max(vcloudthickness, 0.0);
        float trans = exp(-densityavg * shadowk);
        fragcolor = vec4(vec3(clamp(trans, 0.0, 1.0)), 1.0);
    }
]

lazyshader 0 "volumetriccloudshadowapply" [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    uniform sampler2DRect tex0;      // cloud shadow map
    @(gfetchdefs tex8 $msaalight ngfetch)
    @(gfetchdefs tex9)
    uniform mat4 worldmatrix;
    uniform vec3 sunlightdir;
    uniform vec4 tvcloudbounds;      // x=base z, y=top z, z=max dist, w=time
    uniform vec4 tvshadowmapworld;   // x=minx, y=miny, z=world units/texel, w=map size
    uniform vec4 tvcloudshadowparams;// x=strength, y=cloud mid z, z=horizon fade start, w=horizon fade end
    uniform float tvcloudshadowpcf;
    fragdata(0) vec4 fragcolor;

    float tvfetchshadow(vec2 worldxy)
    {
        vec2 uv = (worldxy - tvshadowmapworld.xy) / max(tvshadowmapworld.z, 1.0e-4);
        if(uv.x < 0.5 || uv.y < 0.5 || uv.x > tvshadowmapworld.w - 0.5 || uv.y > tvshadowmapworld.w - 0.5)
            return 1.0;

        float pcf = clamp(tvcloudshadowpcf, 0.0, 2.0);
        if(pcf < 0.5) return texture2DRect(tex0, uv).r;

        float accum = 0.0;
        float weights = 0.0;
        accum += texture2DRect(tex0, uv).r * 4.0; weights += 4.0;
        accum += texture2DRect(tex0, uv + vec2( 1.0, 0.0)).r; weights += 1.0;
        accum += texture2DRect(tex0, uv + vec2(-1.0, 0.0)).r; weights += 1.0;
        accum += texture2DRect(tex0, uv + vec2(0.0,  1.0)).r; weights += 1.0;
        accum += texture2DRect(tex0, uv + vec2(0.0, -1.0)).r; weights += 1.0;

        if(pcf > 1.5)
        {
            accum += texture2DRect(tex0, uv + vec2( 1.0,  1.0)).r * 0.75; weights += 0.75;
            accum += texture2DRect(tex0, uv + vec2(-1.0,  1.0)).r * 0.75; weights += 0.75;
            accum += texture2DRect(tex0, uv + vec2( 1.0, -1.0)).r * 0.75; weights += 0.75;
            accum += texture2DRect(tex0, uv + vec2(-1.0, -1.0)).r * 0.75; weights += 0.75;
        }

        return accum / max(weights, 1.0e-4);
    }

    void main(void)
    {
        vec2 screentc = gl_FragCoord.xy;
        vec4 normalsample = ngfetch(tex8, screentc);
        if(dot(normalsample.rgb, normalsample.rgb) <= 1.0e-6)
        {
            fragcolor = vec4(1.0);
            return;
        }
        @(gdepthunpack depth [gfetch(tex9, screentc)] [
            vec3 wpos = (worldmatrix * vec4(depth*screentc, depth, 1.0)).xyz;
        ] [
            vec4 wpos = worldmatrix * vec4(screentc, depth, 1.0);
            wpos.xyz /= wpos.w;
        ])
        if(depth >= 0.999999)
        {
            fragcolor = vec4(1.0);
            return;
        }
        if(wpos.z >= tvcloudbounds.y)
        {
            fragcolor = vec4(1.0);
            return;
        }

        vec3 sdir = sunlightdir / max(length(sunlightdir), 1.0e-4);
        if(sdir.z <= 1.0e-4)
        {
            fragcolor = vec4(1.0);
            return;
        }

        float horizonfade = smoothstep(tvcloudshadowparams.z, tvcloudshadowparams.w, sdir.z);
        if(horizonfade <= 0.0)
        {
            fragcolor = vec4(1.0);
            return;
        }

        float t = (tvcloudshadowparams.y - wpos.z) / sdir.z;
        float maxt = tvshadowmapworld.w * tvshadowmapworld.z * 2.0;
        t = clamp(t, -maxt, maxt);
        vec2 ps = wpos.xy + sdir.xy * t;
        float shadow = tvfetchshadow(ps);
        float amount = clamp(tvcloudshadowparams.x * horizonfade, 0.0, 1.0);
        float factor = mix(1.0, shadow, amount);
        fragcolor = vec4(vec3(factor), 1.0);
    }
]
