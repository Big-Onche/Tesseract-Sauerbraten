volopt = [ >= (strstr $volumetrictype $arg1) 0 ]

volumetricvariantshader = [
    local volumetrictype
    volumetrictype = $arg3
    maxsteps = $arg4
    spotlight = (>= $arg2 2)
    colorshadow = (>= (mod (+ $arg2 1) 3) 2)
    variantshader 0 $arg1 $arg2 (? (< $arg2 0) [
        attribute vec4 vvertex;
        uniform mat4 lightmatrix;
        void main(void)
        {
            gl_Position = lightmatrix * vvertex;
        }
    ]) [
        @(gfetchdefs tex3)
        @(if (volopt "p") [
            if (|| (volopt "g") (volopt "G")) [if (> $usetexgather 1) [result [
                uniform sampler2DShadow tex4;
            ]] [result [
                uniform sampler2D tex4;
            ]]] [result [
                uniform sampler2DRectShadow tex4;
            ]]
        ])
        @(if $colorshadow [result [
            uniform sampler2DRect tex11;
            #define filtercolorshadow(tc) texture2DRect(tex11, tc.xy @(? (! (volopt "N")) [* 0.5])).rgb
            #define lightshadowtype vec3
        ]] [result [
            #define lightshadowtype float
        ]])
        uniform vec4 lightpos;
        uniform vec3 lightcolor; 
        @(? $spotlight [
            uniform vec4 spotparams;
        ])
        @(? (volopt "p") [
            uniform vec4 shadowparams;
            uniform vec2 shadowoffset;
        ])
        uniform vec3 camera;
        uniform mat4 worldmatrix;
        uniform vec4 fogdir;
        uniform vec3 fogcolor;
        uniform vec2 fogdensity;
        uniform vec4 radialfogscale;
        uniform vec2 shadowatlasscale;
        uniform vec4 volscale;
        uniform float volminstep;
        uniform float voldistclamp;
        uniform float volprefilter;
        fragdata(0) vec4 fragcolor;

        @(if (volopt "p") [
            ? $spotlight [
                vec3 getspottc(vec3 dir, float spotdist)
                {
                    vec2 mparams = shadowparams.xy / max(spotdist, 1e-5);
                    return vec3((dir.xy - spotparams.xy*(spotdist + (spotparams.z < 0.0 ? -1.0 : 1.0)*dir.z)*shadowparams.z) * mparams.x + shadowoffset, mparams.y + shadowparams.w);
                }
            ] [
                vec3 getshadowtc(vec3 dir)
                {
                    vec3 adir = abs(dir);
                    float m = max(adir.x, adir.y), mz = max(adir.z, m);
                    vec2 mparams = shadowparams.xy / max(mz, 1e-5);
                    vec4 proj;
                    if(adir.x > adir.y) proj = vec4(dir.zyx, 0.0); else proj = vec4(dir.xzy, 1.0);
                    if(adir.z > m) proj = vec4(dir, 2.0);
                    return vec3(proj.xy * mparams.x + vec2(proj.w, step(proj.z, 0.0)) * shadowparams.z + shadowoffset, mparams.y + shadowparams.w);
                }
            ]
        ])

        @(if (volopt "p") [
            if (|| (volopt "g") (volopt "G")) [
                ? (> $usetexgather 1) [
                    #define filtershadow(shadowtc) float(shadow2D(tex4, vec3(shadowtc.xy*shadowatlasscale, shadowtc.z)))
                ] [
                    #define filtershadow(shadowtc) step(shadowtc.z, float(texture2D(tex4, shadowtc.xy*shadowatlasscale)))
                ]
            ] [result [
                #define filtershadow(shadowtc) float(shadow2DRect(tex4, shadowtc))
            ]]
        ])
    
        void main(void)
        {
            vec2 tc = gl_FragCoord.xy * volscale.xy;
            @(gdepthunpack depth [gfetch(tex3, tc)] [
                vec3 pos = (worldmatrix * vec4(depth*tc, depth, 1.0)).xyz;
            ] [
                vec4 pos = worldmatrix * vec4(tc, depth, 1.0);
                pos.xyz /= pos.w;
            ])
            vec3 ray = pos.xyz - camera;
            float dist2 = dot(ray, ray), invdist = inversesqrt(dist2), radialdist = min(dist2 * invdist, voldistclamp);
            ray *= invdist;
            vec3 camlight = lightpos.xyz - camera * lightpos.w;
            float camlight2 = dot(camlight, camlight), v = dot(camlight, ray), d = v*v + 1.0 - camlight2;
            lightshadowtype light = lightshadowtype(0.0);
            if(d > 0)
            {
                d = sqrt(d);
                float front = v - d, back = v + d;
                @(? $spotlight [
                    float spotangle = 1.0 - 1.0/spotparams.w, spotangle2 = spotangle*spotangle,
                          rayspot = dot(ray, spotparams.xyz), camspot = dot(camlight, spotparams.xyz),
                          qa = spotangle2 - rayspot*rayspot,
                          qb = rayspot*camspot - spotangle2*v,
                          qc = spotangle2*camlight2 - camspot*camspot,
                          disc = qb*qb - qa*qc;
                    if(disc > 0)
                    {
                        disc = abs(sqrt(disc)/qa);
                        float t = -qb/qa, t0 = t - disc, t1 = t + disc;
                        if(t0*rayspot < camspot) front = max(front, t1);
                        else if(t1*rayspot < camspot) back = min(back, t0);
                        else { front = max(front, t0); back = min(back, t1); }
                ])
                float maxspace = back - front, stepdist = maxspace * @(divf 1.0 $maxsteps);
                front = max(front, 0.0);
                back = min(back, radialdist * lightpos.w);
                float space = back - front;
                if(space > volminstep*stepdist)
                {
                    float dither = dot(fract((gl_FragCoord.xy - 0.5).xyxy*vec4(0.5, 0.5, 0.25, 0.25)), vec4(0.375, 0.9375, 0.25, 0.125));
                    vec3 lightdir = ray * (back + stepdist*dither) - camlight;
                    vec3 raystep = ray * -stepdist;
                    for(int i = 0; i < @maxsteps; i++)
                    {
                        lightdir += raystep;
                        @(if $spotlight [result [
                            float lightdist2 = dot(lightdir, lightdir);
                            float lightinvdist = inversesqrt(lightdist2); 
                            float spotdist = dot(lightdir, spotparams.xyz);
                            float spotatten = 1.0 - (1.0 - lightinvdist * spotdist) * spotparams.w;
                            if(spotatten > 0.0)
                            {
                                float lightatten = clamp(1.0 - lightdist2 * lightinvdist, 0.0, 1.0) * spotatten;
                                @(? (volopt "p") [
                                    vec3 spottc = getspottc(lightdir, spotdist);
                                    lightatten *= filtershadow(spottc);
                                ])
                                light += lightatten @(? $colorshadow [* filtercolorshadow(spottc)]);
                            }
                        ]] [result [
                            float lightatten = clamp(1.0 - length(lightdir), 0.0, 1.0);
                            @(? (volopt "p") [
                                vec3 shadowtc = getshadowtc(lightdir);
                                lightatten *= filtershadow(shadowtc);
                            ])
                            light += lightatten @(? $colorshadow [* filtercolorshadow(shadowtc)]);
                        ]])
                        space -= stepdist;
                        if(space <= 0) break; 
                    }
                    float fogcoord = front/lightpos.w;
                    float foglerp = clamp(exp2(fogcoord*fogdensity.x)*fogdensity.y, 0.0, 1.0);
                    light *= foglerp * stepdist;
                    @(? $spotlight [
                        light /= min(maxspace, 1.0);
                    ])
                }
                @(? $spotlight [}])
            }
            vec2 weights = step(fwidth(radialdist), volprefilter) * (2.0*fract((gl_FragCoord.xy - 0.5)*0.5) - 0.5);
            light -= dFdx(light) * weights.x;
            light -= dFdy(light) * weights.y;
            fragcolor.rgb = light * lightcolor;
            fragcolor.a = 0.0;
        }
    ]
]

volumetricshader = [
    volumetrictype = (concatword $arg1 $arg2)
    shadername = (concatword "volumetric" $volumetrictype $arg3)
    volumetricvariantshader $shadername -1 $arg1 $arg3
    volumetricvariantshader $shadername 0 (concatword $arg1 $arg2) $arg3
    if (volopt "P") [
      volumetricvariantshader $shadername 1 (concatword $arg1 $arg2) $arg3
    ]
    if (volopt "s") [
        volumetricvariantshader $shadername 2 $arg1 $arg3
        volumetricvariantshader $shadername 3 (concatword $arg1 $arg2) $arg3    
        if (volopt "P") [
            volumetricvariantshader $shadername 4 (concatword $arg1 $arg2) $arg3
        ]
    ]
]

volumetricbilateralvariantshader = [
    numtaps = $arg2
    reduced = $arg3 
    filterdir = $arg4
    shader 0 $arg1 [
        attribute vec4 vvertex;
        @(if $reduced [result [
            @(screentexcoord 0)
            varying vec2 texcoord0;
        ]])
        void main(void)
        {
            gl_Position = vvertex;
            @(? $reduced [texcoord0 = vtexcoord0;])
        }
    ] [
        @(gfetchdefs tex3)
        uniform sampler2DRect tex0;
        uniform vec2 bilateralparams;
        @(? $reduced [varying vec2 texcoord0;])
        fragdata(0) vec4 fragcolor;
        void main(void)
        {
            #define tc gl_FragCoord.xy
            #define depthtc @(? $reduced [texcoord0] [gl_FragCoord.xy])
            #define tapvec(type, i) @(? (=s $filterdir "x") [type(i, 0.0)] [type(0.0, i)])
            #define texval(i) texture2DRect(tex0, tc + tapvec(vec2, i))
            #define texvaloffset(i) texture2DRectOffset(tex0, tc, tapvec(ivec2, i))
            #define depthval(i) gfetch(tex3, depthtc + tapvec(vec2, i))
            #define depthvaloffset(i) gfetchoffset(tex3, depthtc, tapvec(ivec2, i))
            vec3 color = texture2DRect(tex0, tc).rgb;
            @(gdepthunpack depth [gfetch(tex3, depthtc)])
            float weights = 1.0;
            @(loopconcat i (* 2 $numtaps) [
                curtap = (- $i $numtaps)
                if (>= $curtap 0) [curtap = (+ $curtap 1)]
                curtapoffset = (* $curtap 2)
                curdepthoffset = (<< $curtapoffset $reduced)
                curtexval = [texval@(? (<= $mintexrectoffset $curtapoffset $maxtexrectoffset) "offset")(@(+f $curtapoffset))]
                curdepthval = [depthval@(? (<= $mintexrectoffset $curdepthoffset $maxtexrectoffset) "offset")(@(+f $curdepthoffset))]
                result [
                    vec3 color@[i] = @[curtexval].rgb;
                    @(gdepthunpack [depth@[i]] $curdepthval)
                    depth@[i] -= depth;
                    float weight@[i] = exp2(@(-f 0 (* $curtap $curtap))*bilateralparams.x - depth@[i]*depth@[i]*bilateralparams.y); 
                    weights += weight@[i];
                    color += weight@[i] * color@[i];
                ]
            ])
            fragcolor = vec4(color / weights, 0.0);
        }
    ]
]

volumetricbilateralshader = [
    volumetricbilateralvariantshader (concatword "volumetricbilateralx" $arg1 $arg2) $arg1 $arg2 x
    volumetricbilateralvariantshader (concatword "volumetricbilateraly" $arg1 $arg2) $arg1 $arg2 y
]

lazyshader 0 "volumetricclouds" [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    @(gfetchdefs tex8 $msaalight ngfetch)
    @(gfetchdefs tex9)
    uniform vec3 camera;
    uniform vec3 sunlightdir;
    uniform mat4 worldmatrix;
    uniform vec4 tvcloudscale; // x,y = fullres/rt, z,w = rt/fullres
    uniform vec4 tvcloudbounds; // x=base z, y=top z, z=max dist, w=time
    uniform vec4 tvclouddome;   // x=dome z/r^2 (signed), y,z=dome center xy
    uniform vec4 tvcloudnoise;  // x=base scale, y=detail scale, z=threshold, w=density
    uniform float vclouddensity;
    uniform float vcloudalpha;
    uniform float vcloudthickness;
    uniform float vcloudphaseg;
    uniform float tvcloudsteps;
    uniform float tvcloudsunsteps;
    uniform float tvcloudsunreuse;
    uniform float tvcloudsunrecalc;
    uniform vec2 vcloudscroll;
    uniform vec3 vcloudskycubelf;
    uniform vec3 vcloudskycubert;
    uniform vec3 vcloudskycubebk;
    uniform vec3 vcloudskycubeft;
    uniform vec3 vcloudskycubedn;
    uniform vec3 vcloudskycubeup;
    uniform vec2 vcloudskycubefront;
    uniform float vcloudskyinherit;
    uniform vec3 vcloudsunlightcolor;
    uniform vec3 vcloudcolour;
    fragdata(0) vec4 fragcolor;

    float tvhash(vec3 p)
    {
        return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123);
    }

    float tvnoise3(vec3 p)
    {
        vec3 i = floor(p), f = fract(p);
        vec3 u = f*f*(3.0 - 2.0*f);

        float n000 = tvhash(i + vec3(0.0, 0.0, 0.0));
        float n100 = tvhash(i + vec3(1.0, 0.0, 0.0));
        float n010 = tvhash(i + vec3(0.0, 1.0, 0.0));
        float n110 = tvhash(i + vec3(1.0, 1.0, 0.0));
        float n001 = tvhash(i + vec3(0.0, 0.0, 1.0));
        float n101 = tvhash(i + vec3(1.0, 0.0, 1.0));
        float n011 = tvhash(i + vec3(0.0, 1.0, 1.0));
        float n111 = tvhash(i + vec3(1.0, 1.0, 1.0));

        float nx00 = mix(n000, n100, u.x);
        float nx10 = mix(n010, n110, u.x);
        float nx01 = mix(n001, n101, u.x);
        float nx11 = mix(n011, n111, u.x);
        float nxy0 = mix(nx00, nx10, u.y);
        float nxy1 = mix(nx01, nx11, u.y);
        return mix(nxy0, nxy1, u.z);
    }

    float tvfbm(vec3 p)
    {
        float v = 0.0, a = 0.5;
        for(int i = 0; i < 4; ++i)
        {
            v += a * tvnoise3(p);
            p = p * 2.03 + vec3(7.3, 19.1, 3.7);
            a *= 0.5;
        }
        return v;
    }

    float tvcloudoffset(vec2 xy)
    {
        vec2 d = xy - tvclouddome.yz;
        return tvclouddome.x * dot(d, d);
    }

    float tvcloudflattenedh(vec3 p)
    {
        return p.z - tvcloudoffset(p.xy);
    }

    vec3 tvcloudhcoeffs(vec3 o, vec3 d)
    {
        vec2 q = o.xy - tvclouddome.yz;
        vec2 u = d.xy;
        float k = tvclouddome.x;
        float a = -k * dot(u, u);
        float b = d.z - 2.0 * k * dot(q, u);
        float c = o.z - k * dot(q, q);
        return vec3(a, b, c);
    }

    int tvquadraticroots(float a, float b, float c, out vec2 roots)
    {
        roots = vec2(0.0);
        if(abs(a) <= 1.0e-8)
        {
            if(abs(b) <= 1.0e-8) return 0;
            roots.x = -c / b;
            return 1;
        }

        float disc = b*b - 4.0*a*c;
        if(disc < 0.0) return 0;

        float s = sqrt(max(disc, 0.0));
        float q = -0.5 * (b + (b < 0.0 ? -s : s));
        float r0 = q / a;
        float r1 = abs(q) > 1.0e-8 ? c / q : (-b + s) / (2.0 * a);
        if(r0 > r1) { float t = r0; r0 = r1; r1 = t; }
        roots = vec2(r0, r1);
        return disc <= 1.0e-8 ? 1 : 2;
    }

    float tvfirstpositiveroot(float a, float b, float c)
    {
        vec2 roots;
        int nroots = tvquadraticroots(a, b, c, roots);
        float t = 1.0e16;
        if(nroots >= 1 && roots.x > 1.0e-4) t = roots.x;
        if(nroots >= 2 && roots.y > 1.0e-4) t = min(t, roots.y);
        return t;
    }

    float tvcloudheval(vec3 hcoeff, float t)
    {
        return (hcoeff.x * t + hcoeff.y) * t + hcoeff.z;
    }

    float tvdensity(vec3 p)
    {
        float thickness = max(tvcloudbounds.y - tvcloudbounds.x, 1.0);
        float h = clamp((tvcloudflattenedh(p) - tvcloudbounds.x) / thickness, 0.0, 1.0);
        float layer = smoothstep(0.05, 0.35, h) * (1.0 - smoothstep(0.65, 0.98, h));

        vec3 windp = p;
        windp.xy += tvcloudbounds.w * vcloudscroll;
        windp.z += tvcloudbounds.w * 2.0;

        float densityk = clamp(vclouddensity, 0.0, 2.0);
        float overcast = densityk * 0.5;
        float base = tvfbm(windp * tvcloudnoise.x);
        float detail = tvfbm((windp + vec3(13.0, -9.0, 17.0)) * tvcloudnoise.y);
        float threshold = mix(tvcloudnoise.z + 0.22, tvcloudnoise.z - 0.14, overcast);
        float shape = mix(base, detail, 0.18);
        shape = smoothstep(threshold - 0.03, threshold + 0.18, shape);
        float edge = 1.0 - smoothstep(0.08, 0.75, shape);
        float erosion = smoothstep(0.35, 0.80, detail);
        float billow = smoothstep(0.20, 0.85, detail);
        float d = shape * (1.0 - 0.30 * edge * erosion);
        d *= mix(0.90, 1.14, billow * shape);
        d = clamp(d, 0.0, 1.0);
        float densityamp = mix(0.40, 1.35, overcast);
        return d * layer * tvcloudnoise.w * densityamp;
    }

    float tvextworldscale()
    {
        return max(tvcloudnoise.x, 1.0e-5);
    }

    float tvbeeralpha(float sigma, float alphamax)
    {
        sigma = clamp(sigma, 0.0, 8.0);
        return min(1.0 - exp(-sigma), alphamax);
    }

    float tvhgphase(float cosTheta, float g)
    {
        float g2 = g * g;
        float denom = max(1.0 + g2 - 2.0 * g * cosTheta, 1.0e-4);
        return (1.0 - g2) / pow(denom, 1.5);
    }

    vec3 tvskycubesample(vec3 dir)
    {
        dir = normalize(dir);
        vec2 front = vcloudskycubefront;
        float fl2 = dot(front, front);
        front = fl2 > 1.0e-6 ? front * inversesqrt(fl2) : vec2(0.0, -1.0);
        vec2 right = vec2(-front.y, front.x);
        // Convert world XY into the local cubemap frame where ft = -Y, bk = +Y.
        vec3 ld = vec3(dot(dir.xy, right), -dot(dir.xy, front), dir.z);
        vec3 ad = abs(ld);
        float wsum = max(ad.x + ad.y + ad.z, 1.0e-5);
        vec3 cx = ld.x >= 0.0 ? max(vcloudskycubert, vec3(0.0)) : max(vcloudskycubelf, vec3(0.0));
        vec3 cy = ld.y >= 0.0 ? max(vcloudskycubebk, vec3(0.0)) : max(vcloudskycubeft, vec3(0.0));
        vec3 cz = ld.z >= 0.0 ? max(vcloudskycubeup, vec3(0.0)) : max(vcloudskycubedn, vec3(0.0));
        return (cx * ad.x + cy * ad.y + cz * ad.z) / wsum;
    }

    float tvsuntrans(vec3 p, vec3 sdir, float thickness, float sunext)
    {
        float tmax;
        float sunbound = sdir.z >= 0.0 ? tvcloudbounds.y : tvcloudbounds.x;
        if(abs(tvclouddome.x) <= 1.0e-12)
        {
            float sdz = abs(sdir.z) > 1.0e-4 ? sdir.z : (sdir.z >= 0.0 ? 1.0e-4 : -1.0e-4);
            tmax = (sunbound - p.z) / sdz;
        }
        else
        {
            vec3 hcoeff = tvcloudhcoeffs(p, sdir);
            tmax = tvfirstpositiveroot(hcoeff.x, hcoeff.y, hcoeff.z - sunbound);
        }
        if(!(tmax > 0.0)) return 1.0;

        tmax = min(tmax, thickness * 6.0);
        const int TV_SUN_STEPS_MAX = 32;
        int sunsteps = int(clamp(tvcloudsunsteps, 2.0, float(TV_SUN_STEPS_MAX)));
        float stepdist = max(tmax / float(sunsteps), 1.0e-3);
        float t = stepdist * 0.35;
        float trans = 1.0;
        for(int j = 0; j < TV_SUN_STEPS_MAX; ++j)
        {
            if(j >= sunsteps) break;
            float d = tvdensity(p + sdir * t);
            float sigma = d * stepdist * sunext;
            float a = tvbeeralpha(sigma, 0.65);
            trans *= 1.0 - a;
            t += stepdist;
            if(trans < 0.05) break;
        }
        return trans;
    }

    void main(void)
    {
        // Map low-res pixel centers to a deterministic full-res texel center.
        // Avoid sampling exact texel edges (e.g. 2x upscale -> integer coords) which can shimmer with rect+nearest depth fetches.
        vec2 screentc = (gl_FragCoord.xy - vec2(0.5)) * tvcloudscale.xy + vec2(0.5);
        // Explicit sky can write depth without gbuffer normals; treat it as background.
        vec4 normalsample = ngfetch(tex8, screentc);
        bool hasscene = dot(normalsample.rgb, normalsample.rgb) > 1.0e-6;
        @(gdepthunpack depth [gfetch(tex9, screentc)] [
            vec3 wpos = (worldmatrix * vec4(depth*screentc, depth, 1.0)).xyz;
        ] [
            vec4 wpos = worldmatrix * vec4(screentc, depth, 1.0);
            wpos.xyz /= wpos.w;
        ])

        vec3 rayvec = wpos.xyz - camera;
        float raydist = length(rayvec);
        if(!(raydist > 0.0))
        {
            fragcolor = vec4(0.0);
            return;
        }
        float scenedist = hasscene ? min(raydist, tvcloudbounds.z) : tvcloudbounds.z;
        if(scenedist <= 1.0)
        {
            fragcolor = vec4(0.0);
            return;
        }

        vec3 ray = rayvec / max(raydist, 1.0e-4);
        float t0 = 0.0, t1 = scenedist;
        float thickness = max(tvcloudbounds.y - tvcloudbounds.x, 1.0);
        if(abs(tvclouddome.x) <= 1.0e-12)
        {
            if(abs(ray.z) < 1.0e-4)
            {
                if(camera.z < tvcloudbounds.x || camera.z > tvcloudbounds.y)
                {
                    fragcolor = vec4(0.0);
                    return;
                }
            }
            else
            {
                float invrz = 1.0 / ray.z;
                float tz0 = (tvcloudbounds.x - camera.z) * invrz;
                float tz1 = (tvcloudbounds.y - camera.z) * invrz;
                if(tz0 > tz1) { float t = tz0; tz0 = tz1; tz1 = t; }
                t0 = max(t0, tz0);
                t1 = min(t1, tz1);
            }
        }
        else
        {
            vec3 hcoeff = tvcloudhcoeffs(camera, ray);
            float hbase = tvcloudbounds.x, htop = tvcloudbounds.y;
            float hstart = hcoeff.z;
            float hend = tvcloudheval(hcoeff, scenedist);
            bool startinside = hstart >= hbase && hstart <= htop;
            bool endinside = hend >= hbase && hend <= htop;

            vec2 broots = vec2(0.0), troots = vec2(0.0);
            int nbottom = tvquadraticroots(hcoeff.x, hcoeff.y, hcoeff.z - hbase, broots);
            int ntop = tvquadraticroots(hcoeff.x, hcoeff.y, hcoeff.z - htop, troots);

            const float TV_ROOT_INF = 1.0e16;
            const float TV_ROOT_NINF = -1.0e16;
            float rb0 = (nbottom >= 1 && broots.x > 0.0 && broots.x < scenedist) ? broots.x : TV_ROOT_INF;
            float rb1 = (nbottom >= 2 && broots.y > 0.0 && broots.y < scenedist) ? broots.y : TV_ROOT_INF;
            float rt0 = (ntop >= 1 && troots.x > 0.0 && troots.x < scenedist) ? troots.x : TV_ROOT_INF;
            float rt1 = (ntop >= 2 && troots.y > 0.0 && troots.y < scenedist) ? troots.y : TV_ROOT_INF;

            float seg0 = 0.0, seg1 = scenedist;
            bool found = true;

            if(!startinside)
            {
                float rfirst = min(min(rb0, rb1), min(rt0, rt1));
                if(!(rfirst < TV_ROOT_INF * 0.5))
                {
                    found = false;
                }
                else
                {
                    float cb0 = rb0, cb1 = rb1, ct0 = rt0, ct1 = rt1;
                    if(cb0 == rfirst) cb0 = TV_ROOT_INF;
                    else if(cb1 == rfirst) cb1 = TV_ROOT_INF;
                    else if(ct0 == rfirst) ct0 = TV_ROOT_INF;
                    else if(ct1 == rfirst) ct1 = TV_ROOT_INF;
                    float rsecond = min(min(cb0, cb1), min(ct0, ct1));
                    float tprobe = rsecond < TV_ROOT_INF * 0.5 ? 0.5 * (rfirst + rsecond) : 0.5 * (rfirst + scenedist);
                    float hprobe = tvcloudheval(hcoeff, tprobe);
                    if(hprobe >= hbase && hprobe <= htop) seg0 = rfirst;
                    else if(rsecond < TV_ROOT_INF * 0.5) seg0 = rsecond;
                    else found = false;
                }
            }

            if(found && !endinside)
            {
                float lb0 = rb0 < TV_ROOT_INF * 0.5 ? rb0 : TV_ROOT_NINF;
                float lb1 = rb1 < TV_ROOT_INF * 0.5 ? rb1 : TV_ROOT_NINF;
                float lt0 = rt0 < TV_ROOT_INF * 0.5 ? rt0 : TV_ROOT_NINF;
                float lt1 = rt1 < TV_ROOT_INF * 0.5 ? rt1 : TV_ROOT_NINF;
                float rlast = max(max(lb0, lb1), max(lt0, lt1));
                if(!(rlast > TV_ROOT_NINF * 0.5))
                {
                    found = false;
                }
                else
                {
                    if(lb0 == rlast) lb0 = TV_ROOT_NINF;
                    else if(lb1 == rlast) lb1 = TV_ROOT_NINF;
                    else if(lt0 == rlast) lt0 = TV_ROOT_NINF;
                    else if(lt1 == rlast) lt1 = TV_ROOT_NINF;
                    float rprev = max(max(lb0, lb1), max(lt0, lt1));
                    float tprobe = rprev > TV_ROOT_NINF * 0.5 ? 0.5 * (rprev + rlast) : 0.5 * rlast;
                    float hprobe = tvcloudheval(hcoeff, tprobe);
                    if(hprobe >= hbase && hprobe <= htop) seg1 = rlast;
                    else if(rprev > TV_ROOT_NINF * 0.5) seg1 = rprev;
                    else found = false;
                }
            }

            if(!found || seg1 <= seg0)
            {
                fragcolor = vec4(0.0);
                return;
            }
            t0 = max(t0, seg0);
            t1 = min(t1, seg1);
        }

        // Keep a tiny epsilon from the camera to avoid self-sampling artifacts, but
        // do not add a large outside-layer skip (it creates a visible disappear zone
        // when crossing the cloud slab boundary).
        t0 = max(t0, 0.1);
        if(t1 <= t0)
        {
            fragcolor = vec4(0.0);
            return;
        }

        const int TV_STEPS_MAX = 128;
        float extworld = tvextworldscale();
        float viewext = extworld * (12.0 * clamp(vcloudalpha, 0.0, 1.0));
        float sunext = extworld * (10.0 * max(vcloudthickness, 0.0));
        int marchsteps = int(clamp(tvcloudsteps, 4.0, float(TV_STEPS_MAX)));
        float raylen = t1 - t0;
        float stepdist = raylen / float(marchsteps);
        // Quantized temporal jitter seed (30 Hz) so the noise pattern can be
        // temporally averaged while still hiding raymarch banding per frame.
        float frame = floor(tvcloudbounds.w * 30.0);
        float jitter = tvhash(vec3(floor(gl_FragCoord.xy), frame));
        float t = t0 + jitter * stepdist;
        float slen = max(length(sunlightdir), 1.0e-4);
        vec3 sdir = sunlightdir / slen;
        float sunup = clamp(sdir.z * 0.5 + 0.5, 0.0, 1.0);
        float phaseg = clamp(vcloudphaseg, -0.95, 0.95);

        vec3 accum = vec3(0.0);
        float trans = 1.0;
        // Cache expensive sun transmittance and refresh periodically.
        // This preserves the overall look while cutting shadow-raymarch calls.
        int suntransreuse = int(clamp(tvcloudsunreuse, 1.0, 16.0));
        float suntransrecalcdensity = clamp(tvcloudsunrecalc, 0.0, 1.0);
        float cachedsuntrans = 1.0;
        int suntranscooldown = 0;
        bool hassuntrans = false;
        for(int i = 0; i < TV_STEPS_MAX; ++i)
        {
            if(i >= marchsteps) break;
            if(t > t1 || trans < 0.03) break;

            vec3 p = camera + ray * t;
            float d = tvdensity(p);
            if(d > 1.0e-4)
            {
                float h = clamp((tvcloudflattenedh(p) - tvcloudbounds.x) / thickness, 0.0, 1.0);
                bool sunworthit = d > suntransrecalcdensity;
                if(!hassuntrans || (suntranscooldown <= 0 && sunworthit))
                {
                    cachedsuntrans = tvsuntrans(p, sdir, thickness, sunext);
                    suntranscooldown = suntransreuse;
                    hassuntrans = true;
                }
                float suntrans = cachedsuntrans;
                float cosT = clamp(dot(ray, sdir), -1.0, 1.0);
                float phase = clamp(tvhgphase(cosT, phaseg) * 0.08, 0.0, 1.5);
                float ambient = mix(0.22, 0.42, h) + 0.18 * sunup;
                float sunabove = clamp(sdir.z, 0.0, 1.0);
                float sunbelow = clamp(-sdir.z, 0.0, 1.0);

                float twilight = 1.0 - smoothstep(0.03, 0.38, sunbelow);
                float horizonwrap = 1.0 - smoothstep(0.06, 0.45, abs(sdir.z));
                float undersideboost = sunbelow * twilight * mix(1.0, 0.45, h);
                float sunreach = clamp(sunabove + 0.22 * horizonwrap + 0.55 * undersideboost, 0.0, 1.0);
                float twilightwow = horizonwrap * twilight;
                float edgeglow = (1.0 - smoothstep(0.12, 0.72, d)) * mix(1.0, 0.55, h);
                ambient += 0.10 * twilightwow * mix(1.0, 0.55, h);
                float direct = sunreach * suntrans * (0.35 + 0.95 * phase);
                direct *= 1.0 + 1.15 * twilightwow;
                // Cheap sunset boost: brighter low-density rims + a little
                // low-angle multiple-scatter fill when the sun skims the horizon.
                direct += 0.55 * twilightwow * edgeglow * (0.12 + 1.10 * phase) * mix(0.35, 1.0, suntrans);
                direct += 0.16 * twilightwow * (1.0 - suntrans) * mix(1.0, 0.60, h);
                float light = ambient + direct;
                light *= mix(0.80, 1.05, tvnoise3(p * (tvcloudnoise.x * 0.35) + vec3(2.0, 11.0, 5.0)));

                float sigma = d * stepdist * viewext;
                float alpha = tvbeeralpha(sigma, 0.55);
                vec3 basecol = max(vcloudcolour, vec3(0.0));
                vec3 litcol = mix(basecol * vec3(0.78, 0.82, 0.90), basecol, suntrans);
                float skyinherit = clamp(vcloudskyinherit, 0.0, 1.0);
                float viewhorizon = 1.0 - clamp(abs(ray.z), 0.0, 1.0);
                float topmix = smoothstep(0.20, 0.95, h);
                float skyxy = clamp(0.25 + 0.85 * viewhorizon + 0.35 * (1.0 - topmix), 0.05, 1.75);
                float skyz = mix(-0.12 - 0.18 * viewhorizon, 0.95, topmix);
                vec3 skybody = tvskycubesample(vec3(ray.xy * skyxy, skyz));
                vec3 ambienttint = mix(vec3(1.0), skybody, skyinherit);
                vec3 directtint = mix(vec3(1.0), skybody, skyinherit * 0.10);
                vec3 suncol = max(vcloudsunlightcolor, vec3(0.0));
                vec3 samplecol = litcol * (ambient * ambienttint) + (litcol * suncol) * (direct * directtint);

                accum += trans * alpha * samplecol;
                trans *= 1.0 - alpha;
            }

            t += stepdist;
            if(suntranscooldown > 0) suntranscooldown--;
        }

        fragcolor = vec4(accum, 1.0 - trans);
    }
]


lazyshader 0 "volumetriccloudsbilateral" [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    // tex0 = low-res cloud RT (RGBA)
    uniform sampler2DRect tex0;
    // tex9 = full-res scene depth (rect or msaa)
    @(gfetchdefs tex9 $msaalight)
    uniform vec4 tvcloudscale;           // xy = output/src, zw = src/output (per pass)
    uniform float tvbilateraldepthscale; // scales raw depth differences
    uniform float vcblurscale;           // bilateral tap spacing in full-res pixels
    uniform vec2 tvcloudblurdir;         // (1,0)=horizontal, (0,1)=vertical
    uniform vec4 viewsize;
    fragdata(0) vec4 fragcolor;

    float fetchDepthLinear(vec2 uv)
    {
        @(gdepthunpack depth [gfetch(tex9, uv)])
        return depth;
    }

    float gaussian1d9(int i)
    {
        // 9-tap separable gaussian-ish weights (sigma ~2.0).
        if(i == 0 || i == 8) return 0.02763;
        if(i == 1 || i == 7) return 0.06628;
        if(i == 2 || i == 6) return 0.12383;
        if(i == 3 || i == 5) return 0.18017;
        return 0.20418;
    }

    void main(void)
    {
        vec2 uv = gl_FragCoord.xy;
        float centerDepth = fetchDepthLinear(uv);

        vec2 centerCloudPix = floor(uv * tvcloudscale.zw);
        vec2 centerCloudUV = centerCloudPix + vec2(0.5);
        vec4 centerCloud = texture2DRect(tex0, centerCloudUV);
        float k = clamp(centerCloud.a * 2.0, 0.0, 1.0);
        float blurstep = max(vcblurscale, 1.0) * mix(2.0, 1.0, k);

        vec4 accumCloud = vec4(0.0);
        float totalWeight = 0.0;

        for(int i = -4; i <= 4; i++)
        {
            vec2 sampleUV = clamp(uv + tvcloudblurdir * (float(i) * blurstep), vec2(0.5), viewsize.xy - vec2(0.5));

            // Snap sampling to the source texel center so depth comparisons line up
            // with the same cloud sample footprint (low-res pass) and stay 1:1 in
            // the full-res vertical pass.
            vec2 cloudPix = floor(sampleUV * tvcloudscale.zw);
            vec2 cloudUV = cloudPix + vec2(0.5);
            vec2 depthProbeUV = clamp(cloudPix * tvcloudscale.xy + vec2(0.5), vec2(0.5), viewsize.xy - vec2(0.5));

            float sampleDepth = fetchDepthLinear(depthProbeUV);
            float depthDiff = abs(sampleDepth - centerDepth) * tvbilateraldepthscale;
            if(depthDiff > 3.0) continue;
            float depthWeight = exp(-depthDiff * depthDiff);

            float spatialWeight = gaussian1d9(i + 4);
            float w = spatialWeight * depthWeight;

            accumCloud += texture2DRect(tex0, cloudUV) * w;
            totalWeight += w;
        }

        fragcolor = accumCloud / max(totalWeight, 1.0e-5);
    }
]

lazyshader 0 "volumetriccloudsupscale" [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    // tex0 = low-res cloud RT (RGBA)
    uniform sampler2DRect tex0;
    // tex9 = full-res scene depth (rect or msaa)
    @(gfetchdefs tex9 $msaalight)
    uniform vec4 tvcloudscale;           // xy = output/src, zw = src/output
    uniform float tvbilateraldepthscale; // scales raw depth differences
    uniform vec4 viewsize;
    fragdata(0) vec4 fragcolor;

    float fetchDepthLinear(vec2 uv)
    {
        @(gdepthunpack depth [gfetch(tex9, uv)])
        return depth;
    }

    void main(void)
    {
        vec2 uv = gl_FragCoord.xy;
        float centerDepth = fetchDepthLinear(uv);

        vec2 srcsize = max(floor(viewsize.xy * tvcloudscale.zw + vec2(0.5)), vec2(1.0));
        vec2 srcf = uv * tvcloudscale.zw;
        vec2 base = floor(srcf);
        vec2 fracp = fract(srcf);

        vec4 accumCloud = vec4(0.0);
        float totalWeight = 0.0;
        vec4 bestCloud = vec4(0.0);
        float bestDepthErr = 1.0e16;

        for(int iy = 0; iy < 2; ++iy)
        {
            for(int ix = 0; ix < 2; ++ix)
            {
                vec2 o = vec2(float(ix), float(iy));
                float wx = ix == 0 ? (1.0 - fracp.x) : fracp.x;
                float wy = iy == 0 ? (1.0 - fracp.y) : fracp.y;
                float spatialWeight = wx * wy;
                if(spatialWeight <= 1.0e-6) continue;

                vec2 cloudPix = clamp(base + o, vec2(0.0), srcsize - vec2(1.0));
                vec2 cloudUV = cloudPix + vec2(0.5);
                vec2 depthProbeUV = clamp(cloudPix * tvcloudscale.xy + vec2(0.5), vec2(0.5), viewsize.xy - vec2(0.5));

                float sampleDepth = fetchDepthLinear(depthProbeUV);
                float depthErr = abs(sampleDepth - centerDepth) * tvbilateraldepthscale;
                if(depthErr < bestDepthErr)
                {
                    bestDepthErr = depthErr;
                    bestCloud = texture2DRect(tex0, cloudUV);
                }

                // Strong depth weighting prevents low-res cloud alpha from leaking
                // onto foreground silhouettes during upscale.
                if(depthErr > 3.0) continue;
                float depthWeight = exp(-depthErr * depthErr);
                float w = spatialWeight * depthWeight;
                accumCloud += texture2DRect(tex0, cloudUV) * w;
                totalWeight += w;
            }
        }

        fragcolor = totalWeight > 1.0e-5 ? (accumCloud / totalWeight) : bestCloud;
    }
]

lazyshader 0 "volumetriccloudshadowmap" [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    uniform vec4 tvcloudbounds;      // x=base z, y=top z, z=max dist, w=time
    uniform vec4 tvclouddome;        // x=dome z/r^2 (signed), y,z=dome center xy
    uniform vec4 tvcloudnoise;       // x=base scale, y=detail scale, z=threshold, w=density
    uniform float vclouddensity;
    uniform float vcloudthickness;   // reused as shadow opacity/strength
    uniform vec2 vcloudscroll;
    uniform vec4 tvshadowmapworld;   // x=minx, y=miny, z=world units/texel, w=map size
    uniform float tvcloudshadowsamples;
    fragdata(0) vec4 fragcolor;

    float tvhash(vec3 p)
    {
        return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123);
    }

    float tvnoise3(vec3 p)
    {
        vec3 i = floor(p), f = fract(p);
        vec3 u = f*f*(3.0 - 2.0*f);

        float n000 = tvhash(i + vec3(0.0, 0.0, 0.0));
        float n100 = tvhash(i + vec3(1.0, 0.0, 0.0));
        float n010 = tvhash(i + vec3(0.0, 1.0, 0.0));
        float n110 = tvhash(i + vec3(1.0, 1.0, 0.0));
        float n001 = tvhash(i + vec3(0.0, 0.0, 1.0));
        float n101 = tvhash(i + vec3(1.0, 0.0, 1.0));
        float n011 = tvhash(i + vec3(0.0, 1.0, 1.0));
        float n111 = tvhash(i + vec3(1.0, 1.0, 1.0));

        float nx00 = mix(n000, n100, u.x);
        float nx10 = mix(n010, n110, u.x);
        float nx01 = mix(n001, n101, u.x);
        float nx11 = mix(n011, n111, u.x);
        float nxy0 = mix(nx00, nx10, u.y);
        float nxy1 = mix(nx01, nx11, u.y);
        return mix(nxy0, nxy1, u.z);
    }

    float tvfbm(vec3 p)
    {
        float v = 0.0, a = 0.5;
        for(int i = 0; i < 4; ++i)
        {
            v += a * tvnoise3(p);
            p = p * 2.03 + vec3(7.3, 19.1, 3.7);
            a *= 0.5;
        }
        return v;
    }

    float tvcloudoffset(vec2 xy)
    {
        vec2 d = xy - tvclouddome.yz;
        return tvclouddome.x * dot(d, d);
    }

    float tvcloudflattenedh(vec3 p)
    {
        return p.z - tvcloudoffset(p.xy);
    }

    float tvdensity(vec3 p)
    {
        float thickness = max(tvcloudbounds.y - tvcloudbounds.x, 1.0);
        float h = clamp((tvcloudflattenedh(p) - tvcloudbounds.x) / thickness, 0.0, 1.0);
        float layer = smoothstep(0.05, 0.35, h) * (1.0 - smoothstep(0.65, 0.98, h));

        vec3 windp = p;
        windp.xy += tvcloudbounds.w * vcloudscroll;
        windp.z += tvcloudbounds.w * 2.0;

        float densityk = clamp(vclouddensity, 0.0, 2.0);
        float overcast = densityk * 0.5;
        float base = tvfbm(windp * tvcloudnoise.x);
        float detail = tvfbm((windp + vec3(13.0, -9.0, 17.0)) * tvcloudnoise.y);
        float threshold = mix(tvcloudnoise.z + 0.22, tvcloudnoise.z - 0.14, overcast);
        float shape = mix(base, detail, 0.18);
        shape = smoothstep(threshold - 0.03, threshold + 0.18, shape);
        float edge = 1.0 - smoothstep(0.08, 0.75, shape);
        float erosion = smoothstep(0.35, 0.80, detail);
        float billow = smoothstep(0.20, 0.85, detail);
        float d = shape * (1.0 - 0.30 * edge * erosion);
        d *= mix(0.90, 1.14, billow * shape);
        d = clamp(d, 0.0, 1.0);
        float densityamp = mix(0.40, 1.35, overcast);
        return d * layer * tvcloudnoise.w * densityamp;
    }

    void main(void)
    {
        vec2 worldxy = tvshadowmapworld.xy + gl_FragCoord.xy * tvshadowmapworld.z;
        float thickness = max(tvcloudbounds.y - tvcloudbounds.x, 1.0);

        int nsamples = int(clamp(tvcloudshadowsamples, 1.0, 8.0));
        float densitysum = 0.0;
        for(int i = 0; i < 8; ++i)
        {
            if(i >= nsamples) break;
            float h = nsamples <= 1 ? 0.6 : (float(i) + 0.5) / float(nsamples);
            float z = mix(tvcloudbounds.x, tvcloudbounds.y, h) + tvcloudoffset(worldxy);
            densitysum += tvdensity(vec3(worldxy, z));
        }

        float densityavg = densitysum / float(max(nsamples, 1));
        float shadowk = 8.0 * max(vcloudthickness, 0.0);
        float trans = exp(-densityavg * shadowk);
        fragcolor = vec4(vec3(clamp(trans, 0.0, 1.0)), 1.0);
    }
]

lazyshader 0 "volumetriccloudshadowapply" [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    uniform sampler2DRect tex0;      // cloud shadow map
    @(gfetchdefs tex8 $msaalight ngfetch)
    @(gfetchdefs tex9)
    uniform mat4 worldmatrix;
    uniform vec3 sunlightdir;
    uniform vec4 tvcloudbounds;      // x=base z, y=top z, z=max dist, w=time
    uniform vec4 tvclouddome;        // x=dome z/r^2 (signed), y,z=dome center xy
    uniform vec4 tvshadowmapworld;   // x=minx, y=miny, z=world units/texel, w=map size
    uniform vec4 tvcloudshadowparams;// x=strength, y=cloud mid h, z=horizon fade start, w=horizon fade end
    uniform float tvcloudshadowpcf;
    uniform vec3 vcloudskycubelf;
    uniform vec3 vcloudskycubert;
    uniform vec3 vcloudskycubebk;
    uniform vec3 vcloudskycubeft;
    uniform vec3 vcloudskycubedn;
    uniform vec3 vcloudskycubeup;
    uniform vec2 vcloudskycubefront;
    uniform float vcloudskyinherit;
    uniform float vcloudshadowinherit;
    uniform vec3 vcloudcolour;
    fragdata(0) vec4 fragcolor;

    float tvcloudoffset(vec2 xy)
    {
        vec2 d = xy - tvclouddome.yz;
        return tvclouddome.x * dot(d, d);
    }

    float tvcloudflattenedh(vec3 p)
    {
        return p.z - tvcloudoffset(p.xy);
    }

    vec3 tvcloudhcoeffs(vec3 o, vec3 d)
    {
        vec2 q = o.xy - tvclouddome.yz;
        vec2 u = d.xy;
        float k = tvclouddome.x;
        float a = -k * dot(u, u);
        float b = d.z - 2.0 * k * dot(q, u);
        float c = o.z - k * dot(q, q);
        return vec3(a, b, c);
    }

    int tvquadraticroots(float a, float b, float c, out vec2 roots)
    {
        roots = vec2(0.0);
        if(abs(a) <= 1.0e-8)
        {
            if(abs(b) <= 1.0e-8) return 0;
            roots.x = -c / b;
            return 1;
        }

        float disc = b*b - 4.0*a*c;
        if(disc < 0.0) return 0;

        float s = sqrt(max(disc, 0.0));
        float q = -0.5 * (b + (b < 0.0 ? -s : s));
        float r0 = q / a;
        float r1 = abs(q) > 1.0e-8 ? c / q : (-b + s) / (2.0 * a);
        if(r0 > r1) { float t = r0; r0 = r1; r1 = t; }
        roots = vec2(r0, r1);
        return disc <= 1.0e-8 ? 1 : 2;
    }

    float tvrootnearestestimate(float a, float b, float c, float testimate)
    {
        vec2 roots;
        int nroots = tvquadraticroots(a, b, c, roots);
        if(nroots <= 0) return 1.0e16;
        float t = roots.x;
        if(nroots >= 2 && abs(roots.y - testimate) < abs(t - testimate)) t = roots.y;
        return t;
    }

    vec3 tvskycubesample(vec3 dir)
    {
        dir = normalize(dir);
        vec2 front = vcloudskycubefront;
        float fl2 = dot(front, front);
        front = fl2 > 1.0e-6 ? front * inversesqrt(fl2) : vec2(0.0, -1.0);
        vec2 right = vec2(-front.y, front.x);
        vec3 ld = vec3(dot(dir.xy, right), -dot(dir.xy, front), dir.z);
        vec3 ad = abs(ld);
        float wsum = max(ad.x + ad.y + ad.z, 1.0e-5);
        vec3 cx = ld.x >= 0.0 ? max(vcloudskycubert, vec3(0.0)) : max(vcloudskycubelf, vec3(0.0));
        vec3 cy = ld.y >= 0.0 ? max(vcloudskycubebk, vec3(0.0)) : max(vcloudskycubeft, vec3(0.0));
        vec3 cz = ld.z >= 0.0 ? max(vcloudskycubeup, vec3(0.0)) : max(vcloudskycubedn, vec3(0.0));
        return (cx * ad.x + cy * ad.y + cz * ad.z) / wsum;
    }

    float tvfetchshadow(vec2 worldxy)
    {
        vec2 uv = (worldxy - tvshadowmapworld.xy) / max(tvshadowmapworld.z, 1.0e-4);
        if(uv.x < 0.5 || uv.y < 0.5 || uv.x > tvshadowmapworld.w - 0.5 || uv.y > tvshadowmapworld.w - 0.5)
            return 1.0;

        float pcf = clamp(tvcloudshadowpcf, 0.0, 2.0);
        if(pcf < 0.5) return texture2DRect(tex0, uv).r;

        float accum = 0.0;
        float weights = 0.0;
        accum += texture2DRect(tex0, uv).r * 4.0; weights += 4.0;
        accum += texture2DRect(tex0, uv + vec2( 1.0, 0.0)).r; weights += 1.0;
        accum += texture2DRect(tex0, uv + vec2(-1.0, 0.0)).r; weights += 1.0;
        accum += texture2DRect(tex0, uv + vec2(0.0,  1.0)).r; weights += 1.0;
        accum += texture2DRect(tex0, uv + vec2(0.0, -1.0)).r; weights += 1.0;

        if(pcf > 1.5)
        {
            accum += texture2DRect(tex0, uv + vec2( 1.0,  1.0)).r * 0.75; weights += 0.75;
            accum += texture2DRect(tex0, uv + vec2(-1.0,  1.0)).r * 0.75; weights += 0.75;
            accum += texture2DRect(tex0, uv + vec2( 1.0, -1.0)).r * 0.75; weights += 0.75;
            accum += texture2DRect(tex0, uv + vec2(-1.0, -1.0)).r * 0.75; weights += 0.75;
        }

        return accum / max(weights, 1.0e-4);
    }

    void main(void)
    {
        vec2 screentc = gl_FragCoord.xy;
        vec4 normalsample = ngfetch(tex8, screentc);
        if(dot(normalsample.rgb, normalsample.rgb) <= 1.0e-6)
        {
            fragcolor = vec4(1.0);
            return;
        }
        @(gdepthunpack depth [gfetch(tex9, screentc)] [
            vec3 wpos = (worldmatrix * vec4(depth*screentc, depth, 1.0)).xyz;
        ] [
            vec4 wpos = worldmatrix * vec4(screentc, depth, 1.0);
            wpos.xyz /= wpos.w;
        ])
        if(depth >= 0.999999)
        {
            fragcolor = vec4(1.0);
            return;
        }
        float h0 = tvcloudflattenedh(wpos.xyz);
        if(h0 >= tvcloudbounds.y)
        {
            fragcolor = vec4(1.0);
            return;
        }

        vec3 sdir = sunlightdir / max(length(sunlightdir), 1.0e-4);
        if(sdir.z <= 1.0e-4)
        {
            fragcolor = vec4(1.0);
            return;
        }

        float horizonfade = smoothstep(tvcloudshadowparams.z, tvcloudshadowparams.w, sdir.z);
        if(horizonfade <= 0.0)
        {
            fragcolor = vec4(1.0);
            return;
        }

        float t;
        if(abs(tvclouddome.x) <= 1.0e-12)
        {
            t = (tvcloudshadowparams.y - wpos.z) / sdir.z;
        }
        else
        {
            vec3 hcoeff = tvcloudhcoeffs(wpos.xyz, sdir);
            float testimate = abs(hcoeff.y) > 1.0e-5 ? (tvcloudshadowparams.y - h0) / hcoeff.y : 0.0;
            t = tvrootnearestestimate(hcoeff.x, hcoeff.y, hcoeff.z - tvcloudshadowparams.y, testimate);
            if(abs(t) >= 1.0e15)
            {
                fragcolor = vec4(1.0);
                return;
            }
        }
        float maxt = tvshadowmapworld.w * tvshadowmapworld.z * 2.0;
        t = clamp(t, -maxt, maxt);
        vec2 ps = wpos.xy + sdir.xy * t;
        float shadow = tvfetchshadow(ps);
        float amount = clamp(tvcloudshadowparams.x * horizonfade, 0.0, 1.0);
        float factor = mix(1.0, shadow, amount);

        float shadowinherit = clamp(vcloudshadowinherit, 0.0, 1.0);
        if(shadowinherit <= 1.0e-4)
        {
            fragcolor = vec4(vec3(factor), 1.0);
            return;
        }

        float k = clamp(amount * (1.0 - shadow), 0.0, 1.0);
        vec3 basecol = max(vcloudcolour, vec3(0.0));
        // Use a stable upper/sun-facing lookup direction so shadow hue follows
        // the cloud palette (base color + sky inheritance) without extra sampling.
        vec3 skydir = vec3(sdir.xy * 0.45, clamp(0.75 + 0.20 * sdir.z, 0.35, 1.0));
        vec3 skybody = tvskycubesample(skydir);
        vec3 cloudtint = basecol * mix(vec3(1.0), skybody, clamp(vcloudskyinherit, 0.0, 1.0));
        float lum = dot(cloudtint, vec3(0.2126, 0.7152, 0.0722));
        vec3 hue = lum > 1.0e-4 ? cloudtint / lum : vec3(1.0);
        hue = clamp(hue, vec3(0.0), vec3(4.0));

        vec3 grayfactor = vec3(factor);
        vec3 tintfactor = clamp(grayfactor * hue, vec3(0.0), vec3(1.0));
        float sat = shadowinherit * smoothstep(0.02, 0.25, k);
        fragcolor = vec4(mix(grayfactor, tintfactor, sat), 1.0);
    }
]
